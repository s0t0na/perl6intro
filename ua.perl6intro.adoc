= Вступ до Perl6
Naoum Hankache <naoum@hankache.com>; Дмитро Ясколко <mescalito.ua@gmail.com>;
:description:  Загальна інтродукція до Perl 6
:keywords: perl6, perl 6, введення, perl6intro, введення до perl 6, інтродукція до 6, вивчення perl6
:Revision: 0.1
:icons: font
:source-highlighter: pygments
//:pygments-style: manni
:source-language: perl6
:pygments-linenums-mode: table
:toc: left
:toc-title: Зміст
:doctype: book
:lang: uk

Цей документ має на меті надати швидкий огляд мови програмування Perl 6.
Новачкам у Perl 6 цей документ надасть можливість почати вивчення та виркористання цієї мови.

Деякі розділи цього документа посилаються на інші (більш досконалі та точні) частини http://docs.perl6.org[документації до Perl 6]. 
Вам слід прочитати їх, якщо потребуєте більше інформації на окремі теми.

Всюди у цьому документі ви знайдете приклади до найбільш обговорюваних тем. Аби краще їх зрозуміти, будь ласка, знайдіть трохи часу аби відтворити їх.

.Ліцензія
Цей документ ліцензовано за міжнародною ліцензією Creative Commons Attribution Share-Alike 4.0 (Із зазначенням авторства — Розповсюдження на тих самих умовах).
Аби побачити копію цієї лізензії, перейдіть за посиланням:

* https://creativecommons.org/licenses/by-sa/4.0/.

.Долучення
Якщо ви хочете долучитися до вдосконалення цього документа, перейдіть до:

* https://github.com/hankache/perl6intro

.Відгуки
Будь-які відгуки вдячно ся приймають на:

* naoum@hankache.com - English
* mescalito.ua@gmail.com - Українська

Якщо вам сподобалася ця робота, позначте зірочкою репозиторій за посиланням: link:https://github.com/hankache/perl6intro[Github].

.Переклади
* Англійська: http://perl6intro.com
* Болгарська: http://bg.perl6intro.com
* Іспанська: http://es.perl6intro.com
* Китайська: http://zh.perl6intro.com
* Німецька: http://de.perl6intro.com
* Португальська: http://pt.perl6intro.com
* Фразцузька: http://fr.perl6intro.com
* Голандська: http://nl.perl6intro.com
* Японська: http://ja.perl6intro.com
* Українська: http://ua.perl6intro.com

:sectnums:

== Вступ
=== Що таке Perl 6
Perl 6 це високорівнева мова програмування загального призначення з поступовою типізацією.
Perl 6 є багатопарадигмальною мовою, яка підтримує Процедурне, Об'єктно-орієнтоване та Функціональне програмування.

.Гасло Perl 6: 
* ІБНОСЗЦ Існує більш ніж один спосіб зробити це. TMTOWTDI (Вимовляється Tim Toady).
* Прості речі мають лишатися простими, складні мають простішати, а неможливі мають стати складними.

=== Визначення
* *Perl 6*: Позначення  мови програмування в межах добірки тестів.
Реалізації, які проходять добірку тестів без помилок, вважаються Perl 6.
* *Rakudo*: Компілятор Perl 6.
* *Rakudobrew*: менеджер встановлення Rakudo.
* *Zef*: встановлювач модулів Perl 6.
* *Rakudo Star*: колекція, яка містить Rakudo, Zef, добірку модулів Perl 6 та документацію.

=== Встановлення Perl 6.
.Linux

Аби встановити Rakudo Star, виконайте наступні команди в своєму терміналі:
----
wget https://rakudo.perl6.org/downloads/star/rakudo-star-2017.07.tar.gz
tar xfz rakudo-star-2017.07.tar.gz
cd rakudo-star-2017.07
perl Configure.pl --gen-moar --prefix /opt/rakudo-star-2017.07
make install
----
Аби дізнатися по інші способи, перейдіть до http://rakudo.org/how-to-get-rakudo/#Installing-Rakudo-Star-Linux

.macOS
Доступними є чотири варіанти:

* Дотримуватися тих самих кроків, що й для Linux
* Встановити через homebrew: `brew install rakudo-star`
* Встановити з MacPorts: `sudo port install rakudo` 
* Завантажити останній встановлювач з https://rakudo.perl6.org/downloads/star/ (файл з розширенням .dmg)

.Windows
. Завантажте останній встановлювач (файл з розширенням .msi) з https://rakudo.perl6.org/downloads/star/ +
Якщо у вас 32-бітна система, завантажте файл х86; якщо 64-бітна, файл х86_64.
. Піcля встановлення переконайтеся,  що `C:\rakudo\bin` додано до змінної PATH.

.Docker
. Отримайте офіційний образ для Docker `docker pull rakudo-star`
. Далі запустіть контейнер з цим образом `docker run -it rakudo-star`

=== Виконання коду Perl 6

Виконувати код Perl 6 можна в режимі інтерактивного інтерпретатора команд або REPL (Read-Eval-Print Loop). Для цього відкрийте вікно терміналу, наберіть `perl6` та натисніть [Enter]. Це призведе до появи запрошення `>`. Далі, наберіть рядок коду та натисніть [Enter], інтрерпретатор надрукує значення або результат виконання цього рядка. Далі ви можете ввести інший рядок, або набрати `exit` та натиснути [Enter] аби завершити сесію інтерпретатора.

Також ви можете записати свій код у файл, зберегти та виконати його. Є рекомендованим надавати скриптам Perl 6 розширення `.pl6`. Виконати такий файл можна набравши `perl6 ваш_скрипт.pl6` у термінальному вікні та натиснувши [Enter]. На відміну від інтерактивного режиму це не призведе до негайного друку результатів виконання коду: код має містити команди на кшталт `say` аби надрукувати результати виконання.

Інтерактивний режим здебільшого вживають, коли треба виконати якийсь конкретний фрагмент коду, зазвичай єдиний рядок. Програми більші за один рядое краще зберігати у файл і потім виконувати їх. 

Один рядок можна також виконати з командного рядка в неінтерактивному режимі,  написавши `perl6 -e 'ваш код тут'` та натиснувши [Enter].       	 

[Підказка]
--
Rakudo Star вже містить редактор, який  допоможе вам отримати якнайбільше від інтерактивного режиму.

Якщо ви встановили звичайний Rakudo замість Rakudo Star, тоді ви, можливо, не маєте змоги редагувати рядки (стрілки вгору та вниз для навігації по історії, ліворуч та праворуч для редарування поточного рядку, TAB для автодоповненя). Виконайте наступні команди, аби отримати все це:

* `zef install Linenoise` спрацює на Windows, Linux та MacOS
* `zef install Readline` якщо у вас Linux та ви полюбляєте бібліотеку _Readline_
--

=== Текстові редактори

Оскільки більшість часу ми писатимемо та зберігатимемо  наші програми Perl 6 у файлах, нам стане у пригоді пристойний текстовий редактор, який розуміє синтаксис Perl 6. 

Особисто я надаю перевагу http://www.vim.org/[Vim], автор оригінального (англомовного) тексту використовує https://atom.io/[Atom] - це модерні текстові редактори, які вміють  підсвічувати синтаксис Perl 6 одразу після встановлення. https://atom.io/packages/language-perl6[Perl 6 FE] це альтернативний плагін для підсвічування синтаксису, який походить від оригінального пакету, але містить багато виправлень та доповнень. 
	
Інші люди у спільноті користуються https://www.gnu.org/software/emacs/[Emacs] чи http://padre.perlide.org/[Padre].

Свіжі версії Vim розуміють синтаксис Perl 6 одразу після встановлення, Emacs та Padre  потребуюьт встановлення додаткових пакетів.


=== Вітаю Світ!

Ми почнемо з ритуалу `Вітаю світ`.

[source,perl6]
say 'Вітання Світові!';

Це також може бути написане як

[source,perl6]
'Вітаю світ!'.say;

===  Огляд синтаксису

Perl 6 є *вільним за формою*: більшість часу ви можете використовувати довільну кількість пробілів, проте у певних випадках  пробіл  має значення.

*Твердження* це, зазвичай, логічний рядок коду, який має закінчуватися крапкою з комою:
`say "Hello" if True;`

*Вираз* це спеціальний тип твердження, який повертає значення:
`1+2` поверне `3`

*Значення* бувають:

* *Змінними*: це значення, якіими можно керувати за міняти.
* *Літералами*: це сталі значення, як число чи рядок.

*Оператори* класифіковані за типами:

|===

| *Тип* | *Пояснення* | *Приклад*

| Префіксні | Перед значенням | ++1

| Інфіксні | Між значеннями | 1+2

| Постфіксні | Після значення | 1++

| Контейнерні | Навколо значення | (1)

| Постконтейнерні | Після значення, навколо іншого | Array[1]

|===

==== Ідентифікатори

Ідентифікатори, це імена, які ви даєте значенням, коли визначаете їх.

.Правила:
* Вони мають починатися з алфавітного символа, чи нижнього  підкреслювання
* Вони можуть містити числа, за винятком першого символа
* Вони можуть містити дефіси та апострофи (за винятком першої та останньої позиції) за умови, що праворуч від кожного дефіса чи апострофа знаходиться алфавітний символ.

|===

| Вірно | Невірно

| var1 | 1var

| var-one | var-1

| var'one | var'1

| var1_ | var1'

| _var1 | -var

| змінна1 | 1змінна

|=== 

.Угода іменування

* Стиль верблюда: `variableNo1`

* Шашличний стиль: `variable-no1`

* Стиль змії: `variable_no1`

Ви можете довільно іменувати ваші ідентифікатори, але ознакою гарного тону є використання якогось одного стилю.

Використання осмислених назв полегшить ваше життя (та життя інших).

* `var1 = var2 * var3` синтаксично вірно, але призначення кожної змінної не є очевидним.
* `monthly-salary = daily-rate * working-days` значно кращій варіант іменування змінних. 
 
==== Коментарі
Коментар, це текст, ігнорований компілятором, який слугує для пояснення (саме пояснення, а не цитування) коду.

Коментарі ся поділяють на три типи:

* Однорядкові:
[source,perl6]
# Це коментар в один рядок

* Вбудовані:
[source,perl6]
say #`(Це вбудований коментар) "Hello World."

* Багаторядкові:
[source,perl6]
-----------------------------
=begin comment
Це багаторядковий коментар.
Коментар 1
Коментар 2
=end comment
-----------------------------

==== Лапки
Рядки мають бути обмежені поодинокими, чи подвійними лапками.

Завжди використовуйте подвійні лапки якщо:

* Ваш рядок містить апостроф.

* Ваш рядок містить змінну, яку має бути розгорнуто.

[source,perl6]
-----------------------------------
say 'Вітаю, Світ';   # Вітаю, Світ 
say "Вітаю, світ";   # Вітаю, Світ
say "Об'єм";         # Об'єм
my $name = 'Андрій Кузьменко';
say 'Вітаю $name';   # Вітаю $name
say "Вітаю $name";   # Вітаю Андрій Кузьменко
-----------------------------------

== Оператори

=== Загальні оператори
У таблиці нижче перераховані найбільш уживані оператори.
[cols="^.^5m,^.^5m,.^20,.^20m,.^20m", options="header"]
|===

| Оператор | Тип | Опис | Приклад | Результат

| + | Інфіксний | Додавання | 1 + 2 | 3

| - | Інфіксний | Віднімання | 3 - 1 | 2

| * | Інфіксний | Множення | 3 * 2 | 6

| ** | Інфіксний | Ступінь | 3 ** 2 | 9

| / | Інфіксний | Ділення | 3 / 2 | 1.5

| div | Інфіксний | Цілочисленне ділення (округлення до меншого) | 3 div 2 | 1

| % | Інфіксний | Залишок від ділення | 7 % 4 | 3

.2+| %% .2+| Інфіксний .2+| Ділимість | 6 %% 4 | False

<| 6 %% 3 <| True

| gcd | Інфіксний | Найбільший спільній дільник | 6 gcd 9 | 3

| lcm | Інфіксний | Найменше спільне кратне | 6 lcm 9 | 18

| == | Інфіксний | Арифметичне порівняння | 9 == 7  | False

| != | Інфіксний | Арифметичне не дорівнює | 9 != 7  | True

| < | Інфіксний | Менше | 9 < 7  | False

| > | Інфіксний | Більше | 9 > 7  | True

| \<= | Інфіксний | Менше чи дорівнює | 7 \<= 7  | True

| >= | Інфіксний | Більше чи дорівнює | 9 >= 7  | True

| eq | Інфіксний | Текстове порівняння | "John" eq "John"  | True

| ne | Інфіксний | Текстове не дорівнює | "John" ne "Jane"  | True

| = | Інфіксний | Привласнення | my $var = 7  | Присвоює значення `7` змінній `$var`

.2+| ~ .2+| Інфіксний .2+| Злиття рядків | 9 ~ 7 | 97

<m| "Вітаю " ~ "вас"  <| Вітаю вас

.2+| x .2+| Інфіксний .2+| Повторення рядків | 13 x 3  | 131313

<| "Вітаю " x 3  <| Вітаю Вітаю Вітаю

.5+| ~~ .5+| Інфіксний .5+| Розумний пошук входження | 2 ~~ 2  | True

<| 2 ~~ Int <| True

<| "Perl 6" ~~ "Perl 6" <| True

<| "Perl 6" ~~ Str <| True

<| "enlightenment" ~~ /light/ <| ｢light｣

.2+| ++ | Префіксний | Інкремент | my $var = 2; ++$var;  | Збільшити змінну на 1 та повернути результат `3`

<m| Постфіксний <d| Інкремент <m| my $var = 2; $var++;  <| Повернути `2` а помтім збільшити змінну на 1

.2+|\--| Префіксний | Декремент | my $var = 2; --$var;  | Зменшити змінну на 1 та повернути результат `1`

<m| Постфіксний <d| Декремент <m| my $var = 2; $var--;  <| Повернути змінну `2` по тому зменшити її на `1`

.3+| + .3+| Префіксний .3+| Привести операнд до числового типу | +"3"  | 3

<| +True <| 1

<| +False <| 0

.3+| - .3+| Префіксний .3+| Привести операнд до числового типу та інвертувати знак | -"3"  | -3

<| -True <| -1

<| -False <| 0

.6+| ? .6+| Префіксний .6+| Привести операнд до логічного типу | ?0 | False

<| ?9.8 <| True

<| ?"Вітаю" <| True

<| ?"" <| False

<| my $var; ?$var; <| False

<| my $var = 7; ?$var; <| True

| ! | Префіксний | Привести операнд до логічного типу та повернути протилежне значення | !4 | False

| .. | Інфіксний | Конструктор  послідовностей |  0..5  | Створює послідовність від 0 до 5

| ..^ | Інфіксний | Конструктор  послідовностей |  0..^5  | Створює послідовність від 0 до 4

| ^.. | Інфіксний | Конструктор  послідовностей |  0^..5  | Створює  послідовність від 1 до 5

| \^..^ | Інфіксний | Конструктор  послідовностей |  0\^..^5  | Створюжж послідовність від 1 до 4. Також відомий під назвою "котик".

| ^ | Префіксний | Конструктор  послідовностей |  ^5  | Те саме що 0..^5 Створює послідовність від 0 до 4

| ... | Інфіксний | Ледащий конструктор списків |  0...9999  | Повертає послідовність на вимогу 

.2+| {vbar} .2+| Префіксний .2+| Сплощення | {vbar}(0..5)  | (0 1 2 3 4 5)

<| {vbar}(0\^..^5)  <| (1 2 3 4)

|===

=== Зворотні оператори

Додавання R перед будь-яким оператором призведе до обертання напрямку їх дії.

[cols=".^m,.^m,.^m,.^m", options="header"]
|===

| Звичайний оператор | Результат | Зворотній оператор | Результат

| 2 / 3 | 0.666667 | 2 R/ 3 | 1.5

| 2 - 1 | 1 | 2 R- 1 | -1

|===


=== Оператори згортання

Оператори згортання працюють зі списками знвчень.

[cols=".^m,.^m,.^m,.^m", options="header"]
|===
| Звичайний оператор | Результат | Оператор згортання | Результат

| 1 + 2 + 3 + 4 + 5 | 15 | [+] 1,2,3,4,5 | 15

| 1 * 2 * 3 * 4 * 5 | 120 | [*] 1,2,3,4,5 | 120

|===

NOTE: Аби отримати повний список операторів разом з ъх пріоритетами, перейдіть до https://docs.perl6.org/language/operators

== Змінні

Змінні Perl 6 класифіковано за трьома категоріями: скаляри, масиви, та хеши (асоцітивні масиви).

*Сигіл* ("Знак" Латиною) це символ, який слугує префіксом для категоризації змінних.

* `$` позначає скаляри

* `@` позначає масиви

* `%` позначає хеши

=== Скаляри

Скаляр зберігає єдине значення чи посилання

[source,perl6]
----
# Рядок
my $name = 'Андрій Кузьменко';
say $name;

# Ціле число
my $age = 99;
say $age;
----

Залежно від значення, яке зберігає скаляр,  над ним можна виконувати певний набір операцій.

[source,perl6]
.Рядок
----
my $name = 'Андрій Кузьменко';
say $name.uc;
say $name.chars;
say $name.flip;
----

----
АНДРІЙ КУЗЬМЕНКО
16
окнемьзуК йірднА
----

NOTE: Аби дізнатися про повний список методів, які придатні до застосування до рядків перейдіть до  https://docs.perl6.org/type/Str

[source,perl6]
.Ціле число
----
my $age = 17;
say $age.is-prime;
----

----
True
----

NOTE: Аби дізнатися про повний список методів, які придатні до застосування до цілих чисел перейдіть до https://docs.perl6.org/type/Int

[source,perl6]
.Раціональне число 
----
my $age = 2.3;
say $age.numerator;
say $age.denominator;
say $age.nude;
----

----
23
10
(23 10)
----

NOTE: Аби дізнатися про повний список методів, які придатні до застосування до раціональних чисел перейдіть до https://docs.perl6.org/type/Rat

=== Масиви

Масиви, це списки, які містять багато значень 

[source,perl6]
----
my @animals = 'верблюд','лама','сова';
say @animals;
----

Багато операцій може бути виконано надо масивами, як показано в наступному прикладі:

TIP: Тільда `~` призначена для конкатенації рядків.

[source,perl6]
.`Програма`
----
my @animals = 'верблюд','вікунья','лама';
say "У зоопарку є " ~ @animals.elems ~ " тварин";
say "Ці тварини: " ~ @animals;
say "Я маю намір віддати до зоопарку сову";
@animals.push("сова");
say "Тепер у зоопарку є: " ~ @animals;
say "Перша тварина, яка в нас з'явилася, це " ~ @animals[0];
@animals.pop;
say "На жаль сова втекла та в нас лишилися: " ~ @animals;
say "Ми закриваємо зоопарк та залишаемо собі лише одну тварину";
say "Ми плануємо віддати: " ~ @animals.splice(1,2) ~ " та залишити " ~ @animals;
----

.`Вивід`
----
У зоопарку є 3 тварини
Ці тварини: верблюд вікунья лама
Я маю намір віддати до зоопарку сову
Тепер у зоопарку є: верблюд вікунья лама сова
Перша тварина, яка в нас з'явилася, це верблюд
На жаль сова втекла та в нас лишилися: верблюд вікунья лама
Ми закриваємо зоопарк та залишаємо собі лише одну тварину
Ми плануємо віддати: вікунья лама та залишити верблюд
----

.Пояснення
`.elems` повертає кількість елементів масиву. +
`.push()` додає один чи більше елементів в кінець масиву. +
Ми можемо звернутися до певного елемента масиву вказавши його положення `@animals[0]`. +
`.pop` видаляє останній елемент масиву та повертає його. +
`.splice(a,b)` видалить (та поверне) `b` елементів починаючи з позиції `a`.

==== Масиви фіксованого розміру

Оголошення звичайного масиву виглядає наступним чином:

[source,perl6]
my @array;

Звичайний масив может бути довільного розміру, тому його називають автоматично розширюваним. +
Такий масив приймає довільну кількість значень без будь-яких обмежень.

Також, на противагу, ми можемо створити масив фіксованого розміру. +
Доступ до таких масивів є неможливим за межами їх визначеного розміру.

[source,perl6]
my @array[3];

Цей масив здатен зберігати завбільшки 3 значення, з індексами від 0 до 2.

[source,perl6]
----
my @array[3];
@array[0] = "перше значення";
@array[1] = "друге значення";
@array[2] = "третє значення";
----

Ви не зможете додати четверте значення до такого масиву.

[source,perl6]
----
my @array[3];
@array[0] = "перше значення";
@array[1] = "друге значення";
@array[2] = "третє значення";
@array[3] = "четверте значення";
----

----
Index 3 for dimension 1 out of range (must be 0..2)
----

==== Багатовимірні масиви
Масиви, які ми бачили до цього часу є одновимірними. +
На щастя, у Perl 6 ми можемо визначати багатовимірні масиви.

[source,perl6]
my @tbl[3;2];

Цей масив двовимірний.
Перший вимір може збарігати завбільшки 3 значення, та другий вимір не більше ніж 2 значення.

Думвйте про це, як про таблицю 3х2.

[source,perl6]
----
my @tbl[3;2];
@tbl[0;0] = 1;
@tbl[0;1] = "x";
@tbl[1;0] = 2;
@tbl[1;1] = "y";
@tbl[2;0] = 3;
@tbl[2;1] = "z";
say @tbl
----

----
[[1 x] [2 y] [3 z]]
----

.Візуальна репрезентація масива:
----
[1 x]
[2 y]
[3 z]
----

NOTE: Повну інструкцію до масивів можна знайти за посиланням: https://docs.perl6.org/type/Array

==== Хеши (асоціативні масиви)
[source,perl6]
.Хеш - це набір пар Ключ/Значення.
----
my %capitals = ('UK','Лондон','Ukraine','Київ');
say %capitals;
----

[source,perl6]
.Інший стислий спосіб заповнення хеша:
----
my %capitals = (UK => 'London',Ukraine => 'Kyiv');
say %capitals;
----

Деякі методи, які моуть бути застосовані до хешів:
[source,perl6]
.`Програма`
----
my %capitals = (UK => 'Лондон', Ukraine => 'Київ');
%capitals.push: (France => 'Париж');
say %capitals.kv;
say %capitals.keys;
say %capitals.values;
say "Столиця Франції це: " ~ %capitals<France>;
----

.`Вивід`
----
(France Париж UK Лондон Ukraine Київ)
(France UK Ukraine)
(Київ Лондон Париж)
Столиця Франції це: Париж
----

.Пояснення
`.push: (ключ => 'Значення')` додає нову пару ключ/значення. +
`.kv` повертає список, який містить усі ключі та значення. +
`.keys` повертає список, який містить усі ключі. +
`.values` повертає список, який містить усі значення. +
Ви можете звернутися до необхідного значення у хеші, вказавши його ключ `%hash<ключ>`

NOTE: Повну довідку по хешам ви можете отримати тут: https://docs.perl6.org/type/Hash

=== Типи
У попередніх прикладах ми не вказували типи значень, які мають зберігати змінні.

TIP: `.WHAT` поверне тип значення, збереженого у змінній.

[source,perl6]
----
my $var = 'Text';
say $var;
say $var.WHAT;

$var = 123;
say $var;
say $var.WHAT;
----

Як бачимо з прикладу наведеного вище, тип значення у `$var` спочатку був (Str), потім став (Int).

Такий стиль програмування називають динамічною типізацією. Динамічною в тому сенсі, що змінні можуть зберігати значення будь-якого типу.

Тепер спробуйте виконати приклад ничже: +
Зверніть увагу на `Int` перед ім'ям змінної.

[source,perl6]
----
my Int $var = 'Text';
say $var;
say $var.WHAT;
----

Цей код не буде виконано, натомість з'явиться помилка: `Type check failed in assignment to $var; expected Int but got Str`

Відмінність у тому, що зазделегідь вказали, що змінна має бути типу (Int).
Коли ми спробували присвоїти змінній значення типу (Str), компілятор повернув помилку.

Такий стиль програмування називають статичною типізацією. Статичною в тому сенсі, що тип змінної визначають перед тим, як присвоїти значення і він не може бти змінений.

Perl 6 класифіковано як мову з *поступовою типізацією*, тобто вона дозволяє як *статичну* так і *динамічну* типізацію.

.Масиви та хеши також можуть бути статично типізованими:
[source,perl6]
----
my Int @array = 1,2,3;
say @array;
say @array.WHAT;

my Str @multilingual = "Hello","Вітаю","Hallo","您好","안녕하세요","こんにちは";
say @multilingual;
say @multilingual.WHAT;

my Str %capitals = (UK => 'London', Ukraine => 'Kyiv');
say %capitals;
say %capitals.WHAT;

my Int %country-codes = (UK => 44, Ukraine => 38);
say %country-codes;
say %country-codes.WHAT;
----

.У списку нижче найчастіше уживані типи:
Скоріш за все ви ніколи не використаєте перші два, але вони наведені для інформації.
[cols="^.^1m,.^3m,.^2m,.^1m, options="header"]
|===

| *Тип* | *Опис* | *Приклад* | *Результат*

| Mu | Корінь ієрархії типів Perl 6 | |

| Any | Базовий клас за замовчуванням для усіх нових класів, та для більшості вбудованих класів | |

| Cool | Значення, яке може бути рядком та цілим числом одночасно | my Cool $var = 31; say $var.flip; say $var * 2; | 13 62

| Str | Рядок символів | my Str $var = "NEON"; say $var.flip; | NOEN

| Int | Ціле число (довільної точності) | 7 + 7 | 14

| Rat | Раціональне число (обмеженої точності) | 0.1 + 0.2 | 0.3

| Bool | Логічне значення | !True | False

|===

=== Інтроспекція (відображення)

Інтроспекція це процес отримання інформації про властивості об'єкта, такі як тип. +
В одному з попередніх прикладів ми використали `.WHAT` аби отримати тип змінної.

[source,perl6]
----
my Int $var;
say $var.WHAT;    # (Int)
my $var2;
say $var2.WHAT;   # (Any)
$var2 = 1;
say $var2.WHAT;   # (Int)
$var2 = "Hello";
say $var2.WHAT;   # (Str)
$var2 = True;
say $var2.WHAT;   # (Bool)
$var2 = Nil;
say $var2.WHAT;   # (Any)
----

Тип змінної, яка збурігає значення має відношення до її значення. +
Тип явно оголошеної пустої змінної є типом, з яким її оголосили. +
Типом пустої змінної, тип якої не було оголошего явно, є `(Any)` + 
Аби очистити значення змінної, треба присвоїти їй значення `Nil`.

=== Область видимості

Перш, ніж вперше використати змінну, вона має бути оголошена.

У Perl 6 існує декілька способів це зробити. Досі ми виуористовували `my`.

[source,perl6]
my $var=1;

Оголошення у вигляді `my` надає змінній область видимості.
Іншими словами, змінна буде досяжна лише у тому блоці, де вона була оголошена.

У Perl 6 блок обмежений `{ }`.
Якщо межі блоку не знайдені, змінна буде досяжною у всьому скрипті Perl 6.

[source,perl6]
----
{
  my Str $var = 'Text';
  say $var;   # is accessible
}
say $var;   # is not accessible, returns an error
----

Оскільки змінна досяжна лише у межах блоку, те саме ім'я змінної можна використати також у іншому блоці.

[source,perl6]
----
{
  my Str $var = 'Text';
  say $var;
}
my Int $var = 123;
say $var;
----

=== Привласнення чи зв'язування?
У попередніх прикладах ми бачили як *привласнити* значення змінній. +
*Привласнення* виконують за допомогою оператора `=`.
[source,perl6]
----
my Int $var = 123;
say $var;
----

Ми маємо змогу змінити значення привласнене змінній:

[source,perl6]
.Привласнення
----
my Int $var = 123;
say $var;
$var = 999;
say $var;
----

.`Виведення`
----
123
999
----

З іншого боку, ми не можемо змінити значення, яке є *зв'язаним* зі змінною. +
*Зв'язування* роблять за допомогою оператора `:=`.

[source,perl6]
.Зв'язування.
----
my Int $var := 123;
say $var;
$var = 999;
say $var;
----

.`Виведення`
----
123
Cannot assign to an immutable value
----

[source,perl6]
.Змінні можуть також бути зв'язаними з іншими змінними:
----
my $a;
my $b;
$b := $a;
$a = 7;
say $b;
$b = 8;
say $a;
----

.`Виведення`
----
7
8
----

Зв'язування змінних є двонаправленим. +
`$a := $b` та `$b := $a` мають однаковий ефект.

NOTE: Аби дізнатися більше про змінні, завітайте до https://docs.perl6.org/language/variables

== Функції та мутатори

#TODO 
